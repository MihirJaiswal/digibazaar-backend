generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum OrderStatus {
  PENDING
  COMPLETED
  CANCELLED
  IN_PROGRESS
  DELIVERED
  REFUNDED
  REJECTED
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
}

enum CategoryEnum {
  WEB_DEVELOPMENT
  GRAPHIC_DESIGN
  DIGITAL_MARKETING
  CONTENT_WRITING
  VIDEO_ANIMATION
  SOFTWARE_DEVELOPMENT
  MOBILE_DEVELOPMENT
  DATA_ANALYTICS
  BUSINESS
  AUDIO_PRODUCTION
  PHOTOGRAPHY
  VIRTUAL_ASSISTANTS
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  PAYMENT
  REFUND
}

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  username      String   @unique
  password      String
  profilePic    String?
  bio           String?
  country       String
  phone         String?  @unique
  walletBalance Float    @default(0)
  badges        Json?
  socialLinks   Json?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  isSeller      Boolean  @default(false)

  // Marketplace & Project Relations
  gigs                  Gig[]
  gigOrders             GigOrder[]       @relation("GigBuyerOrders")
  messages              Message[]
  gigReviews            GigReview[]
  gigStars              GigStar[]
  gigLikes              GigLike[]
  conversationsAsSeller Conversation[]   @relation("SellerConversations")
  conversationsAsBuyer  Conversation[]   @relation("BuyerConversations")
  transactions          Transaction[]
  followers             Follow[]         @relation("Followers")
  following             Follow[]         @relation("Following")
  notifications         Notification[]
  orderUpdates          GigOrderUpdate[]
  refunds               Refund[]
  deliveriesAsSeller    GigDelivery[]    @relation("DeliverySeller")
  deliveriesAsBuyer     GigDelivery[]    @relation("DeliveryBuyer")

  // Community Relations
  communitiesCreated   Community[]        @relation("CreatorCommunities")
  communityMemberships CommunityMember[]
  communityPosts       CommunityPost[]
  communityComments    CommunityComment[]
  GigOrder             GigOrder[]
  Store                Store?
  ProductOrder         ProductOrder[]
}

model Gig {
  id             String       @id @default(uuid())
  userId         String
  category       CategoryEnum
  title          String
  desc           String
  price          Int
  cover          String
  images         Json
  shortDesc      String
  deliveryTime   Int
  revisionNumber Int
  resume         String?
  yearsOfExp     Int
  features       Json
  sales          Int          @default(0)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relations
  user    User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders  GigOrder[]
  reviews GigReview[]
  likes   GigLike[]
  stars   GigStar[]
}

model GigStar {
  id        String   @id @default(uuid())
  gigId     String
  userId    String
  star      Int
  createdAt DateTime @default(now())

  // Relations
  gig  Gig  @relation(fields: [gigId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model GigOrder {
  id            String      @id @default(uuid())
  gigId         String
  buyerId       String
  sellerId      String
  price         Int
  status        OrderStatus @default(PENDING)
  //for adding specific requirement
  requirement   String
  paymentIntent String
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relations
  gig        Gig              @relation(fields: [gigId], references: [id], onDelete: Cascade)
  buyer      User             @relation(fields: [buyerId], references: [id], name: "GigBuyerOrders", onDelete: Cascade)
  seller     User             @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  updates    GigOrderUpdate[]
  refunds    Refund[]
  deliveries GigDelivery[]
}

model GigOrderUpdate {
  id                   String    @id @default(uuid())
  gigOrderId           String
  sellerId             String
  title                String
  content              String
  expectedDeliveryDate DateTime?
  createdAt            DateTime  @default(now())

  // Relations
  gigOrder GigOrder @relation(fields: [gigOrderId], references: [id], onDelete: Cascade)
  seller   User     @relation(fields: [sellerId], references: [id], onDelete: Cascade)
}

model GigDelivery {
  id         String   @id @default(uuid())
  gigOrderId String
  sellerId   String
  buyerId    String
  fileUrl    String // URL or path to the delivered file(s)
  message    String // Optional message from the seller
  isAccepted Boolean  @default(false) // Whether buyer approved the delivery
  createdAt  DateTime @default(now())

  // Relations
  gigOrder GigOrder @relation(fields: [gigOrderId], references: [id], onDelete: Cascade)
  seller   User     @relation(name: "DeliverySeller", fields: [sellerId], references: [id], onDelete: Cascade)
  buyer    User     @relation(name: "DeliveryBuyer", fields: [buyerId], references: [id], onDelete: Cascade)
}

model Refund {
  id         String   @id @default(uuid())
  gigOrderId String
  userId     String
  amount     Float
  status     String // PENDING, PROCESSED, FAILED
  createdAt  DateTime @default(now())

  // Relations
  gigOrder GigOrder @relation(fields: [gigOrderId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Conversation {
  id           String   @id @default(uuid())
  sellerId     String
  buyerId      String
  readBySeller Boolean  @default(false)
  readByBuyer  Boolean  @default(false)
  lastMessage  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  seller   User      @relation(fields: [sellerId], references: [id], name: "SellerConversations", onDelete: Cascade)
  buyer    User      @relation(fields: [buyerId], references: [id], name: "BuyerConversations", onDelete: Cascade)
  messages Message[]
}

model Message {
  id             String   @id @default(uuid())
  conversationId String
  userId         String
  content        String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model GigReview {
  id        String   @id @default(uuid())
  gigId     String
  userId    String
  star      Int
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  gig  Gig  @relation(fields: [gigId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model GigLike {
  id        String   @id @default(uuid())
  gigId     String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  gig  Gig  @relation(fields: [gigId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Transaction {
  id          String          @id @default(uuid())
  userId      String
  type        TransactionType // e.g., "Deposit", "Withdrawal", "Payment"
  amount      Float
  description String?
  createdAt   DateTime        @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  // Relations
  follower  User @relation("Followers", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  content   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Community Models (Redditâ€‘like Features)
model Community {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  image       String?  @db.Text
  creatorId   String
  isPublic    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  rules       Json?
  tags        Json?
  coverImage  String?  @db.Text
  allowNSFW   Boolean  @default(false)

  // Relations
  creator User              @relation("CreatorCommunities", fields: [creatorId], references: [id], onDelete: Cascade)
  members CommunityMember[]
  posts   CommunityPost[]
}

model CommunityMember {
  id          String   @id @default(uuid())
  communityId String
  userId      String
  role        String   @default("member") // e.g., "admin", "moderator", "member"
  joinedAt    DateTime @default(now())

  // Relations
  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([communityId, userId])
}

model CommunityPost {
  id          String   @id @default(uuid())
  communityId String
  userId      String
  title       String
  content     String
  image       String?
  video       String?
  audio       String?
  link        String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  community Community          @relation(fields: [communityId], references: [id], onDelete: Cascade)
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  comments  CommunityComment[]
  postLikes PostLike[]
}

model PostLike {
  id        String   @id @default(uuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  communityPost CommunityPost @relation(fields: [postId], references: [id], onDelete: Cascade)
}

model CommunityComment {
  id        String   @id @default(uuid())
  postId    String
  userId    String
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  post  CommunityPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  votes Vote[]

  // Self-referencing relationship for replies
  parentId String?
  parent   CommunityComment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies  CommunityComment[] @relation("CommentReplies")
}

model Vote {
  id        String @id @default(uuid())
  commentId String
  userId    String

  // Relations
  comment CommunityComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
}

// Shopify Clone & Warehouse Management Models

model Store {
  id           String   @id @default(uuid())
  ownerId      String   @unique
  name         String
  description  String?
  theme        String? // User can select a theme
  logo         String? // Store logo URL
  domain       String? @unique // Custom domain like mystore.com
  subdomain    String? @unique // Subdomain like mystore.shopify.com
  isActive     Boolean  @default(true) // Can be disabled by admin
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  owner          User              @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  products       Product[]
  orders         ProductOrder[]
  shippingMethods ShippingMethod[]
  settings       StoreSetting?
}

model StoreSetting {
  id             String  @id @default(uuid())
  storeId        String  @unique
  currency       String  @default("USD") // Default currency
  taxRate        Float? // Optional tax rate
  shippingEnabled Boolean @default(true)
  analytics      Json? // Store analytics settings
  createdAt      DateTime @default(now())

  // Relations
  store Store @relation(fields: [storeId], references: [id], onDelete: Cascade)
}

model Product {
  id          String   @id @default(uuid())
  storeId     String
  title       String
  description String?
  price       Float
  sku         String? // Stock Keeping Unit
  mainImage   String
  images      Json? // Additional images as JSON array
  stock       Int      @default(0) // Fallback stock if no variants are used
  weight      Float? // For shipping calculations
  dimensions  Json? // e.g., {"length":10, "width":5, "height":2}
  tags        Json? // Array of tags/categories
  costPerItem Float? // Cost per item
  profit      Float? // Profit per item
  margin      Float? // Margin per item
  categoryId  String? // Optional link to a product category
  createdAt   DateTime @default(now())
  isPublished Boolean  @default(false)
  updatedAt   DateTime @updatedAt

  // Relations
  store         Store            @relation(fields: [storeId], references: [id], onDelete: Cascade)
  variants      ProductVariant[]
  orderItems    OrderItem[]
  inventories   Inventory[]
  PurchaseOrder PurchaseOrder[]
  reviews       ProductReview[]
  likes         ProductLike[]
  comments      ProductComment[]
  StockMovement StockMovement[]
}

model ProductReview {
  id        String  @id @default(uuid())
  productId String
  userId    String
  rating    Int
  review    String
  Product   Product @relation(fields: [productId], references: [id])
}

model ProductLike {
  id        String  @id @default(uuid())
  productId String
  userId    String
  Product   Product @relation(fields: [productId], references: [id])
}

model ProductComment {
  id        String  @id @default(uuid())
  productId String
  userId    String
  comment   String
  Product   Product @relation(fields: [productId], references: [id])
}

model ProductVariant {
  id              String   @id @default(uuid())
  productId       String
  name            String? // e.g., "color", "size", "material"
  value           String? // e.g., "Red, Large", "cotton"
  price           Float?
  additionalPrice Float    @default(0)
  stock           Int      @default(0)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  product   Product     @relation(fields: [productId], references: [id], onDelete: Cascade)
  OrderItem OrderItem[]
}

model ProductOrder {
  id               String        @id @default(uuid())
  storeId          String
  userId           String // Customer who placed the order
  totalPrice       Float
  status           OrderStatus   @default(PENDING)
  shippingAddress  Json // Detailed shipping info (address, phone, etc.)
  paymentStatus    PaymentStatus @default(PENDING)
  paymentIntent    String?
  trackingNumber   String?
  shippingMethodId String? // Optional: Selected shipping method
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  // Relations
  store          Store           @relation(fields: [storeId], references: [id], onDelete: Cascade)
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  items          OrderItem[]
  shipment       Shipment?
  shippingMethod ShippingMethod? @relation(fields: [shippingMethodId], references: [id])
}

model OrderItem {
  id               String   @id @default(uuid())
  orderId          String
  productId        String
  productVariantId String? // Optional: If a variant was selected
  quantity         Int      @default(1)
  unitPrice        Float
  totalPrice       Float // Calculated as unitPrice * quantity
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  order          ProductOrder    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product        Product         @relation(fields: [productId], references: [id], onDelete: Cascade)
  productVariant ProductVariant? @relation(fields: [productVariantId], references: [id], onDelete: Cascade)
}

model Warehouse {
  id          String   @id @default(uuid())
  name        String
  location    String // Full address, city, or region
  capacity    Int // Total capacity (units or weight)
  contactInfo Json? // e.g., { "phone": "...", "email": "..." }
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  coordinates Json? // e.g., { "latitude": 37.7749, "longitude": -122.4194 }
  availableCapacity Float? // Available capacity (units or weight)
  usedCapacity Float? // Used capacity (units or weight)
  totalStock Float? // Total stock (units or weight)

  // Relations
  inventories   Inventory[]
  shipments     Shipment[]
  PurchaseOrder PurchaseOrder[]
  StockMovement StockMovement[]
}

model Inventory {
  id           String    @id @default(uuid())
  warehouseId  String
  productId    String
  quantity     Int       @default(0)
  reorderLevel Int       @default(0) // Threshold for triggering restock
  lastReorder  DateTime? // Date when last reorder occurred
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  warehouse Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  product   Product   @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([warehouseId, productId])
}

model Supplier {
  id          String   @id @default(uuid())
  name        String
  contactInfo Json? // e.g., email, phone, address as JSON
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  purchaseOrders PurchaseOrder[]
}

model PurchaseOrder {
  id          String    @id @default(uuid())
  supplierId  String
  warehouseId String
  productId   String
  quantity    Int
  status      String // e.g., "Ordered", "Received", "Cancelled"
  orderedAt   DateTime  @default(now())
  receivedAt  DateTime? // Date when order was fulfilled
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  supplier  Supplier  @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  warehouse Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  product   Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model ShippingMethod {
  id                    String   @id @default(uuid())
  storeId               String
  name                  String
  description           String?
  price                 Float
  estimatedDeliveryDays Int
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  store     Store          @relation(fields: [storeId], references: [id], onDelete: Cascade)
  orders    ProductOrder[]
  shipments Shipment[]
}

model Shipment {
  id               String    @id @default(uuid())
  productOrderId   String    @unique
  warehouseId      String
  shippingMethodId String?
  trackingNumber   String?
  trackingStatus   String    @default("Pending") // New field: "Pending", "In Transit", "Delivered"
  shippedAt        DateTime?
  deliveredAt      DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  productOrder   ProductOrder    @relation(fields: [productOrderId], references: [id], onDelete: Cascade)
  warehouse      Warehouse       @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  shippingMethod ShippingMethod? @relation(fields: [shippingMethodId], references: [id])
}

model StockMovement {
  id          String   @id @default(uuid())
  warehouseId String
  productId   String
  changeType  String // "INCOMING" (stock added) or "OUTGOING" (stock deducted)
  quantity    Int
  createdAt   DateTime @default(now())

  // Relations
  warehouse Warehouse @relation(fields: [warehouseId], references: [id], onDelete: Cascade)
  product   Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
}
